import { Message } from '@marigold/components';

import { Block, Content } from '@/components/Container';
import Caption from '@/components/Caption';
import DemoLink from '@/components/DemoLink';
import Preview from '@/components/Preview';

import SelectExample from './_components/SelectExample';
import TabsBasicExample from './_components/TabsBasicExample';
import TabsAnatomy from './_components/TabsAnatomy';

import TabsBaiscContent from './_components/tabs-basic.mdx';
import TabsCompoundComponentContent from './_components/tabs-compound-component.mdx';

<Block className='text-center'>

    # Compound Components

    <Caption>
    Explore the power of compound components in React with this tutorial.
    </Caption>

</Block>

<Content>

In our application, we often encounter components that rely on each other, sharing state and logic. This
reliance can lead to challenges in managing state, ensuring consistent behavior, and maintaining clean,
organized code. To address these challenges and facilitate a well-structured, reusable, and
customizable API design, React uses a pattern called compound components.

Remember the `<select>` element in HTML with its `<option>` children? Compound components work similarly but
are more powerful and flexible. In this tutorial, we'll explore how to use this pattern to build customizable
and versatility components.

```html
<select>
  <option value="backlog">Backlog</option>
  <option value="in-progress">In Progress</option>
  <option value="in-review">In Review</option>
  <option value="done">Done</option>
  <option value="wont-do">Won't do</option>
</select>
```

## Benefits

### State Management

Compound components provide a clear way to express relationships between components, making it easier to understand
and manage how different parts of your UI interact. By managing their own internal state and sharing it among child
components, compound components free you from handling state management yourself. This built-in state management ensures
consistent behavior across all related components.

An example of this internal state management can be seen with [Marigold's Select](https://www.marigold-ui.io/components/form/select)
component. The disabled state (`disabledKeys`) and the `onChange` handler are both managed within the parent component (`<Select>`),
instead of handling this on every children individually.

```tsx
<Select label="Status" disabledKeys={['wont-do']}>
  <Select.Option id="backlog">Backlog</Select.Option>
  <Select.Option id="in-progress">In Progress</Select.Option>
  <Select.Option id="in-review">In Review</Select.Option>
  <Select.Option id="done">Done</Select.Option>
  <Select.Option id="wont-do">Won't do</Select.Option>
</Select>
```

The provided code demonstrates how centralizing state management in a parent component
can simplify your code. In this example, the `<Select>` component handles tasks like disabling
options and tracking user-selected items, eliminating the need for you to handle these
tasks manually.

<Message messageTitle="Single Import" variant="info">
  Note how compound components usually export their related components using dot
  notation (`Select.Option`). This technique allows you to bundle the parent and
  child components together in a single export, making it easy to access all
  related components.
</Message>

### Customization

Additionally, compound components enhance reusability and customization. You can create a flexible parent component with
customizable children, allowing you to reuse and adapt the components for different requirements effortlessly.

In the following example, the parent `<Select>` component manages the state and behavior, while the child `<Select.Option>`
components can be individually styled and customized, allowing for a flexible and tailored user interface.

<Preview>
  <SelectExample />
</Preview>

```tsx mark=2[38:63],4:11
// from ./_components/SelectExample.tsx 45:56
```

In this example, the `<Select>` component manages the state with the `disabledKeys` prop, which disables specific options based
on their `id`. The state is handled by the parent `<Select>` component, ensuring that the disabled state is applied consistently
across all options without requiring manual checks within each child component.

Furthermore, the `<Select.Option>` component demonstrates how each option can be customized. Inside, we use an `<Inline>` component
to align the `<Indicator>` and `<Text>` components. This setup allows you to style each option individually, adding visual distinction
to the options and making each option both informative and visually distinct.

</Content>

<Content>
## Building a Compound Component

Now let's build a compound component in React. We'll create a simple tabs component to demonstrate the compound component pattern,
showcasing how it can create flexible and reusable UI elements while making it easy and convenient to manage related state.

The tabs component will let users switch between content panels by clicking on tab headers. The component will manage which panel is
displayed and visibly highlight the current tab header so users know which panel is active.

Here you can see how the finished tab component should look and function.

<Preview>
  <TabsBasicExample />
</Preview>

### A basic Tabs Component

Let's start with a simple, naive approach to building the tabs component. By beginning with the basics, we can understand the core functionality
before gradually enhancing it with more advanced features and best practices.

</Content>

<TabsBaiscContent />

<Content>

This concludes our implementation of a basic tab component. While this implementation may seem fine initially,
its limitations will become quickly apparent in real-world applications.

For instance, what if we need to style tabs individually or add interactive elements inside tab contents that interact with the tabs component itself?
With the current implementation, these tasks are not easily achievable, if achievable at all.

Another issue is that the tabs prop currently mixes data and visual presentation, which can become problematic as the component grows.
Separating data (such as tab titles and content) from visual presentation (such as styling and layout) is a best practice for maintainability
and scalability. By mixing these concerns, it becomes harder to manage and update the component over time.

This lack of flexibility and separation of concerns makes it challenging to customize the tabs according to specific design or functional requirements.
As a result, the component may not meet the diverse needs of different projects or UI designs, limiting its usefulness in practical scenarios.

## Compound Components to the Rescue

Now let's see how we can use compound components to address these limitations and create a more flexible and customizable tab component.

First, we want to separate the concerns of data and visual presentation more effectively. This will allow us to define the structure and behavior of the tab component separately
from its styling and layout. This will enable us to customize tabs more easily and use the component in a more familiar way.

Once this refactoring is complete, we aim to leverage the separation of concerns by enabling custom code to tap into the state of the tab component and even modify the tabs' state.
This concept is known as [inversion of control](https://kentcdodds.com/blog/inversion-of-control), and it's a powerful pattern for enhancing component reusability and customization.

### Identifying the Parts

Before we start our refactoring, let's first dissect the component by examining its anatomy. Instead of focusing on the code, we'll analyze how the component is structured visually,
without getting into the nitty-gritty details. This will help us identify the key components and their relationships within the component.

The image below is from Adobe's React Aria library, but it also aligns well with our `<Tabs>` component. It breaks down the component into three main parts:

- **Tab**: Represents each individual tab item, with its titel and possibly being selected (active).
- **TabList**: Acts as a container for all tab items, facilitating navigation between tabs.
- **TabPanel**: Displays the content associated with the currently active tab.

<TabsAnatomy />

Based on this breakdown, we will create three child components for our Tabs component, each responsible for managing a specific aspect of the functionality.

</Content>

<TabsCompoundComponentContent />

---

<Content>

downsides of this implementation: we have a very ugly "data object" with all information and JSX as property inside it. this makes it hard(er) to work with the ... why?
add a new feature that jumps to a certain tab, making this almost like a wizard (using TabsContext) or something.

!!! we can use the component without having to put everything in a "data object" first.

colocation of content and title (we had this in the objects also?)

</Content>
