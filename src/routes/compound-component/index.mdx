import { Message } from '@marigold/components';

import { Block, Content } from '@/components/Container';
import Caption from '@/components/Caption';
import DemoLink from '@/components/DemoLink';
import Preview from '@/components/Preview';

import SelectExample from './_components/SelectExample';

import TabsDoc from './tabs.mdx';

<Block className='text-center'>

    # Compound Components

    <Caption>
    Explore the power of compound components in React with this tutorial.
    </Caption>

</Block>

<Content>

In our application, we often encounter components that rely on each other, sharing state and logic. This
reliance can lead to challenges in managing state, ensuring consistent behavior, and maintaining clean,
organized code. To address these challenges and facilitate a well-structured, reusable, and
customizable API design, React uses a pattern called compound components.

Remember the `<select>` element in HTML with its `<option>` children? Compound components work similarly but
are more powerful and flexible. In this tutorial, we'll explore how to use this pattern to build customizable
and versatility components.

```html
<select>
  <option value="backlog">Backlog</option>
  <option value="in-progress">In Progress</option>
  <option value="in-review">In Review</option>
  <option value="done">Done</option>
  <option value="wont-do">Won't do</option>
</select>
```

## Benefits

### State Management

Compound components provide a clear way to express relationships between components, making it easier to understand
and manage how different parts of your UI interact. By managing their own internal state and sharing it among child
components, compound components free you from handling state management yourself. This built-in state management ensures
consistent behavior across all related components.

An example of this internal state management can be seen with [Marigold's Select](https://www.marigold-ui.io/components/form/select)
component. The disabled state (`disabledKeys`) and the `onChange` handler are both managed within the parent component,
instead of handling this on every children individually.

```tsx
<Select label="Status" disabledKeys={['wont-do']}>
  <Select.Option id="backlog">Backlog</Select.Option>
  <Select.Option id="in-progress">In Progress</Select.Option>
  <Select.Option id="in-review">In Review</Select.Option>
  <Select.Option id="done">Done</Select.Option>
  <Select.Option id="wont-do">Won't do</Select.Option>
</Select>
```

The provided code demonstrates how centralizing state management in a parent component
can simplify your code. In this example, the `<Select>` component handles tasks like disabling
options and tracking user-selected items, eliminating the need for you to handle these
tasks manually.

<Message messageTitle="Single Import" variant="info">
  Note how compound components usually export their related components using dot
  notation (`Select.Option`). This technique allows you to bundle the parent and
  child components together in a single export, making it easy to access all
  related components.
</Message>

### Customization

Additionally, compound components enhance reusability and customization. You can create a flexible parent component with
customizable children, allowing you to reuse and adapt the components for different requirements effortlessly.

In the following example, the parent `<Select>` component manages the state and behavior, while the child `<Select.Option>`
components can be individually styled and customized, allowing for a flexible and tailored user interface.

<Preview>
  <SelectExample />
</Preview>

```tsx mark=2[38:63],4:11
// from ./_components/SelectExample.tsx 45:56
```

In this example, the `<Select>` component manages the state with the `disabledKeys` prop, which disables specific options based
on their `id`. The state is handled by the parent `<Select>` component, ensuring that the disabled state is applied consistently
across all options without requiring manual checks within each child component.

Furthermore, the `<Select.Option>` component demonstrates how each option can be customized. Inside, we use an `<Inline>` component
to align the `<Indicator>` and `<Text>` components. This setup allows you to style each option individually, adding visual distinction
to the options and making each option both informative and visually distinct.

</Content>

<Content>
## Building a Compound Component

Now let's build a compound component in React. We'll create a simple tab component to demonstrate the compound component pattern,
showcasing how it can create flexible and reusable UI elements while making it easy and convenient to manage related state.

The tab component will let users switch between content panels by clicking on tab headers. The component will manage which panel is
displayed and visibly highlight the current tab header so users know which panel is active.

</Content>

<Block>

### Example 3: Compound component with Context

<DemoLink to="/compound-component/preview/tabs">View Demo</DemoLink>

By leveraging React context, we can provide the necessary states and functions to child components without exposing them through props, resulting in a cleaner and more maintainable codebase.

<TabsDoc />
<div style={{ height: 300 }} />
</Block>
````
