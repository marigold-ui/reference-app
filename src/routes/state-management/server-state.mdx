import ServerStateExample from './_components/ServerStateExample';
import { Block } from '@/components/Container';

{/* 

What is state management?

- take parts of https://react-community-tools-practices-cheatsheet.netlify.app/state-management/overview/

    --> relevant for the tutorial are local, global state and server cache

important! "Server cache is not the same as UI state, and should be handled differently."

---

## Local State

- explain local state (useState on a single component -> maybe just an regular <input>)
- ref compound components ? 
- example: search and filter using `useState`

---

## Global State

- context can be used as global, but another approach to avoid this complexity and decuple your application is using URL as storage
- example: previous introduced search and filter -> from `useState` -> to "URL State"
  (https://tanstack.com/router/v1/docs/framework/react/guide/search-params#search-params-the-og-state-manager)
  (search resulst and "search bar" can be decoupled)
- don't introduce libs like: zustand/redux (when should you use them?)

## Server Cache

- https://epicreact.dev/my-state-management-mistake
- https://betterprogramming.pub/why-you-should-be-separating-your-server-cache-from-your-ui-state-1585a9ae8336
- server cache = keep the data fresh!
- client state vs server state (note that the previous two are types of clients states)
    client: owned completly, synchronous available, always up to date
    server: persisted remotely, async available, potentially out of date
- (maybe? https://tkdodo.eu/blog/react-query-as-a-state-manager)
- example: search results
- explain that they could potentially change, this would be automatically handled by the lib (react-query)
- benefits of this model: managing state and errors (they don't need to be handled locally)

- https://frontendmasters.com/blog/combining-react-server-components-with-react-query-for-easy-data-management/

*/}
<Block>
    <CH.Scrollycoding>

        ```tsx ServerStateExample.tsx focus=24:27
        // from ./_components/ServerStateExample.tsx
        ````
        #### Initializing local state for filters using useState hook

        Here, we use the `useState` hook to manage the local state of our filters. This state will store the user's input for the movie title and category.

        ---

        ```tsx ServerStateExample.tsx focus=63,71:73
        // from ./_components/ServerStateExample.tsx
        ````
        #### Handle User Input: SearchField & Select

        We use the `SearchField` component to allow the user to input a search query. The `onChange` handler updates the local state with the new search term, which triggers a re-fetch of the data.

        The `Select` component allows the user to choose a category. The `onChange` handler updates the local state with the selected category, which also triggers a re-fetch of the data.

        ---

        ```tsx ServerStateExample.tsx focus=29:37
        // from ./_components/ServerStateExample.tsx
        ````
        #### Fetch date from server

        The `fetchData` function builds the API URL with query parameters and fetches data from the server.

        ---

        ```tsx ServerStateExample.tsx focus=39:51
        // from ./_components/ServerStateExample.tsx
        ````
        #### Use React Query to Manage Server State

        The `useQuery` hook from React Query fetches data based on the current filters and manages the server state, including loading and error states.

        ---



        ```tsx ServerStateExample.tsx focus=53:55
        // from ./_components/ServerStateExample.tsx
        ```
        #### Error Handling

        If an error occurs during data fetching, we display an error message.

        ---




        ```tsx ServerStateExample.tsx focus=86
        // from ./_components/ServerStateExample.tsx
        ```
        #### Loading State

        While data is being fetched, we display a loading indicator.

    </CH.Scrollycoding>
</Block>