import DemoLink from '@/components/DemoLink';
import ServerStateDoc from './server-state.mdx';
import CounterExampleDoc from './_components/counter-example.mdx';
import SimpleSearchFilterComponentDoc from './_components/simple-search-filter-example.mdx';
import { Content } from '@/components/Container';
import Preview from '@/components/Preview';
import Counter from './_components/CounterExample';
import SimpleSearchFilterComponent from './_components/SimpleSearchFilterComponent';
import {Aspect, Image, Message} from '@marigold/components';

<Content>
    In React, **state refers to any data that represents the current behavior of an application**. Examples include a list of objects fetched from the server, which item is currently selected, the name of the currently logged-in user and whether a modal is open.

    **State Management is the process of handling changes to state over time**. This involves:

    - Storing an initial value
    - Reading the current value
    - Updating a value

    React applications determine what UI to render based on the current state values. Thus, understanding when and how to use different techniques for managing state is a crucial skill for all React developers, as is deciding where a given piece of state should live.

    For a comprehensive approach to state management, it's important to consider:

    1. **Local State:** This is state that is managed within a single component. It's ideal for state that doesn't need to be shared across multiple components.
    2. **Global State:** This is state that needs to be accessible by multiple components throughout the application. Tools like Context API or Redux can be used to manage global state.
    3. **Server Cache:** This involves state that represents data fetched from a server. Unlike UI state, server cache should be managed differently, often using tools like React Query or SWR to handle data fetching, caching, and synchronization with the server.

    By effectively managing local state, global state, and server cache, you can create a React application that is both efficient and easy to maintain.

    ### Using local state

    Local state in React is the state that is confined to a single component. It's ideal for managing data that doesn't need to be shared across multiple components.
    By mastering these techniques for initializing, reading, updating, and handling local state, you can create dynamic and responsive React components that effectively manage their own data.

    In the following example we have a component which counts the clicks on the button.
    <Preview>
        <Counter />
    </Preview>

    Here's a detailed explanation of how to use local state in React:
</Content>

<CounterExampleDoc />

<Content>
    #### Example: Search and Filter using `useState`
    In the example below we have a simple search/filter component where we can search/filter for movies when typing something in the searchbar. If nothing is found, a corresponding message appears.

    <Preview>
        <SimpleSearchFilterComponent />
    </Preview>
</Content>

<SimpleSearchFilterComponentDoc />

<Content>
    #### Potential disadvantages
    For now the component above works well but let us think where we could possibly improve it to avoid some pitfalls.

    State management complexity:

    * Multiple sources of truth: Using local state (searchQuery and filteredList) means managing state within the component. If the state is also used or needed elsewhere, it can lead to inconsistencies and difficulties in synchronizing state across components.
    * Component bloat: As the component grows in complexity, managing multiple pieces of state within a single component can make it harder to read, maintain, and debug.

    Performance issues:

    * Frequent re-renders: Each time searchQuery or filteredList updates, the component re-renders. If this component is part of a larger application, these frequent re-renders can negatively impact performance, especially if the component is deeply nested or the movie list is large.
    * Inefficient filtering: Filtering the movies array within the handleSearchChange function can become inefficient if the dataset is large. This operation is performed on each keystroke, which can lead to noticeable lag.

    Testability and reusability:

    * Difficult testing: Testing components with local state often requires setting up the component in a specific state to test various scenarios. This can make tests more complex and harder to write.
    * Limited reusability: Local state ties the logic to a specific component. If the filtering logic is needed elsewhere, it has to be duplicated, violating the DRY (Don't Repeat Yourself) principle.

    Limited scalability:
    * Handling more features: As the application grows and more features are added (e.g., additional filters, pagination), managing all these states within a single component becomes cumbersome. It may be better to use a state management library like Context API, Redux or Zustand to handle **global state** more efficiently.

    ### Using global state
    When you have growing applications a point will come where it doesn't feel good to use equal or similar state in multiple components. It also doesn't feel good to pass state through different component until it reaches the component where the state is used (also know as prop drilling).
    When you feel bad about this than it's time to think about global state.
    Primarily, global state refers to state tge is accessible across different components in the application, enabling a centralized and consistent way to manage data.

    #### Why use global state?
    Global state is useful in several scenarios:

    1. **Shared data**: When multiple components need to access and update the same piece of data. For example, user authentication status, theme settings, or language preferences.
    2. **Complex state logic**: When the state logic is complex and needs to be shared across components. For instance, managing the state of a shopping cart in an e-commerce application.
    3. **Consistency**: Ensuring consistency across the application by maintaining a single source of truth for specific data.
    4. **Communication between components**: Facilitating communication between sibling components that do not have a direct parent-child relationship.

    <Aspect ratio="golden">
        <img src="/component-tree-prop-drill.png"
            alt="component_tree_prop_drill" />
    </Aspect>

    In the picture above you see a visualization of a component tree in react. So `ProductPage` contains `Sidebar` and `MainContent`. Sidebar holds `Filter`, `SubCategoryFilter` and `Sort`. The MainContent has `ProductList` and inside ProductList is `ProductItem` rendered.

    There is prop `category` which is used from multiples components. But the thing is that `category` isn't used in any components down the tree. So Sidebar, MainContent and ProductList are just pass down the props to their child components.

    Also when category changes value all the components which uses category will be re-rendered. This can lead to performance issues.

    When changing the prop name or adding another prop which is also needed in a lot of components you have to got through all your components which has the potential for adding bugs.

    <Message messageTitle="Rule of thumb" variant="info">
        There is no official rule, but from experience if you pass props more than 3-levels deep you should consider using global state.
    </Message>

    The good news are that there are some possibilities to avoid these problems.

    #### Context API
    The Context API is built into React and allows you to pass data through the component tree without having to pass props down manually at every level - it's like you "teleport" data down the tree where it is needed.

    <Aspect ratio="golden">
        <img src="/goku.gif"
             alt="goku_teleportation" />
    </Aspect>

    To use Context they are mainly 3 steps necessary:

    1. Create and export it with `export const MyContext = createContext(defaultValue)`.
    2. Pass it to the `useContext(MyContext)` Hook to read it in any child component, no matter how deep.
    3. Wrap children into `<MyContext.Provider value={...}>` to provide it from a parent.

</Content>


{/*
<Content>
    ### Let's break down the state management code example:

    <DemoLink to="/state-management/preview">View Demo</DemoLink>
</Content>

<ServerStateDoc />
*/}